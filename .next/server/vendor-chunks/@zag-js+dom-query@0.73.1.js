"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zag-js+dom-query@0.73.1";
exports.ids = ["vendor-chunks/@zag-js+dom-query@0.73.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@zag-js+dom-query@0.73.1/node_modules/@zag-js/dom-query/dist/index.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zag-js+dom-query@0.73.1/node_modules/@zag-js/dom-query/dist/index.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX_Z_INDEX: () => (/* binding */ MAX_Z_INDEX),\n/* harmony export */   ariaAttr: () => (/* binding */ ariaAttr),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createScope: () => (/* binding */ createScope),\n/* harmony export */   dataAttr: () => (/* binding */ dataAttr),\n/* harmony export */   defaultItemToId: () => (/* binding */ defaultItemToId),\n/* harmony export */   getActiveElement: () => (/* binding */ getActiveElement),\n/* harmony export */   getBeforeInputValue: () => (/* binding */ getBeforeInputValue),\n/* harmony export */   getByText: () => (/* binding */ getByText),\n/* harmony export */   getByTypeahead: () => (/* binding */ getByTypeahead),\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getDataUrl: () => (/* binding */ getDataUrl),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getEventTarget: () => (/* binding */ getEventTarget),\n/* harmony export */   getFirstFocusable: () => (/* binding */ getFirstFocusable),\n/* harmony export */   getFirstTabbable: () => (/* binding */ getFirstTabbable),\n/* harmony export */   getFocusables: () => (/* binding */ getFocusables),\n/* harmony export */   getInitialFocus: () => (/* binding */ getInitialFocus),\n/* harmony export */   getLastTabbable: () => (/* binding */ getLastTabbable),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNextTabbable: () => (/* binding */ getNextTabbable),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getScrollPosition: () => (/* binding */ getScrollPosition),\n/* harmony export */   getTabbableEdges: () => (/* binding */ getTabbableEdges),\n/* harmony export */   getTabbables: () => (/* binding */ getTabbables),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   indexOfId: () => (/* binding */ indexOfId),\n/* harmony export */   isApple: () => (/* binding */ isApple),\n/* harmony export */   isComposingEvent: () => (/* binding */ isComposingEvent),\n/* harmony export */   isDocument: () => (/* binding */ isDocument),\n/* harmony export */   isDom: () => (/* binding */ isDom),\n/* harmony export */   isDownloadingEvent: () => (/* binding */ isDownloadingEvent),\n/* harmony export */   isEditableElement: () => (/* binding */ isEditableElement),\n/* harmony export */   isFirefox: () => (/* binding */ isFirefox),\n/* harmony export */   isFocusable: () => (/* binding */ isFocusable),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isHiddenElement: () => (/* binding */ isHiddenElement),\n/* harmony export */   isInView: () => (/* binding */ isInView),\n/* harmony export */   isIos: () => (/* binding */ isIos),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isModKey: () => (/* binding */ isModKey),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOpeningInNewTab: () => (/* binding */ isOpeningInNewTab),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isSelfTarget: () => (/* binding */ isSelfTarget),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTabbable: () => (/* binding */ isTabbable),\n/* harmony export */   isTouchDevice: () => (/* binding */ isTouchDevice),\n/* harmony export */   isValidTabEvent: () => (/* binding */ isValidTabEvent),\n/* harmony export */   isVisualViewport: () => (/* binding */ isVisualViewport),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit),\n/* harmony export */   isWindow: () => (/* binding */ isWindow),\n/* harmony export */   itemById: () => (/* binding */ itemById),\n/* harmony export */   nextById: () => (/* binding */ nextById),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   observeAttributes: () => (/* binding */ observeAttributes),\n/* harmony export */   observeChildren: () => (/* binding */ observeChildren),\n/* harmony export */   prevById: () => (/* binding */ prevById),\n/* harmony export */   proxyTabFocus: () => (/* binding */ proxyTabFocus),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryAll: () => (/* binding */ queryAll),\n/* harmony export */   raf: () => (/* binding */ raf),\n/* harmony export */   scrollIntoView: () => (/* binding */ scrollIntoView),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAttribute: () => (/* binding */ setAttribute),\n/* harmony export */   setProperty: () => (/* binding */ setProperty),\n/* harmony export */   setStyle: () => (/* binding */ setStyle),\n/* harmony export */   visuallyHiddenStyle: () => (/* binding */ visuallyHiddenStyle),\n/* harmony export */   waitForElement: () => (/* binding */ waitForElement),\n/* harmony export */   waitForElements: () => (/* binding */ waitForElements)\n/* harmony export */ });\n// src/attrs.ts\nvar dataAttr = (guard) => guard ? \"\" : void 0;\nvar ariaAttr = (guard) => guard ? \"true\" : void 0;\n\n// src/constants.ts\nvar MAX_Z_INDEX = 2147483647;\n\n// src/is.ts\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\nvar isObject = (v) => typeof v === \"object\" && v !== null;\nvar isHTMLElement = (el) => isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === \"string\";\nvar isDocument = (el) => isObject(el) && el.nodeType === DOCUMENT_NODE;\nvar isWindow = (el) => isObject(el) && el === el.window;\nvar isVisualViewport = (el) => isObject(el) && el.constructor.name === \"VisualViewport\";\nvar getNodeName = (node) => {\n  if (isHTMLElement(node)) return node.localName || \"\";\n  return \"#document\";\n};\nfunction isRootElement(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nvar isNode = (el) => isObject(el) && el.nodeType !== void 0;\nvar isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in el;\n\n// src/contains.ts\nfunction contains(parent, child) {\n  if (!parent || !child) return false;\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;\n  return parent === child || parent.contains(child);\n}\n\n// src/env.ts\nfunction getDocument(el) {\n  if (isDocument(el)) return el;\n  if (isWindow(el)) return el.document;\n  return el?.ownerDocument ?? document;\n}\nfunction getDocumentElement(el) {\n  return getDocument(el).documentElement;\n}\nfunction getWindow(el) {\n  if (isShadowRoot(el)) return getWindow(el.host);\n  if (isDocument(el)) return el.defaultView ?? window;\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;\n  return window;\n}\nfunction getActiveElement(rootNode) {\n  let activeElement = rootNode.activeElement;\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement;\n    if (el === activeElement) break;\n    else activeElement = el;\n  }\n  return activeElement;\n}\n\n// src/data-url.ts\nfunction getDataUrl(svg, opts) {\n  const { type, quality = 0.92 } = opts;\n  if (!svg) throw new Error(\"[get-data-url]: could not find the svg element\");\n  const win = getWindow(svg);\n  const doc = win.document;\n  const serializer = new win.XMLSerializer();\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svg);\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source);\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString);\n  }\n  const svgBounds = svg.getBoundingClientRect();\n  const dpr = win.devicePixelRatio || 1;\n  const canvas = doc.createElement(\"canvas\");\n  const image = new win.Image();\n  image.src = svgString;\n  canvas.width = svgBounds.width * dpr;\n  canvas.height = svgBounds.height * dpr;\n  const context = canvas.getContext(\"2d\");\n  context.scale(dpr, dpr);\n  return new Promise((resolve) => {\n    image.onload = () => {\n      context.drawImage(image, 0, 0);\n      resolve(canvas.toDataURL(type, quality));\n    };\n  });\n}\n\n// src/platform.ts\nvar isDom = () => typeof document !== \"undefined\";\nfunction getPlatform() {\n  const agent = navigator.userAgentData;\n  return agent?.platform ?? navigator.platform;\n}\nvar pt = (v) => isDom() && v.test(getPlatform());\nvar ua = (v) => isDom() && v.test(navigator.userAgent);\nvar vn = (v) => isDom() && v.test(navigator.vendor);\nvar isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nvar isMac = () => pt(/^Mac/);\nvar isSafari = () => isApple() && vn(/apple/i);\nvar isFirefox = () => ua(/firefox\\//i);\nvar isApple = () => pt(/mac|iphone|ipad|ipod/i);\nvar isIos = () => pt(/iP(hone|ad|od)|iOS/);\nvar isWebKit = () => ua(/AppleWebKit/);\nvar isModKey = (event) => isApple() ? event.metaKey : event.ctrlKey;\n\n// src/event.ts\nfunction getBeforeInputValue(event) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget;\n  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);\n}\nfunction getComposedPath(event) {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();\n}\nfunction getEventTarget(event) {\n  const composedPath = getComposedPath(event);\n  return composedPath?.[0] ?? event.target;\n}\nvar isSelfTarget = (event) => {\n  return contains(event.currentTarget, getEventTarget(event));\n};\nfunction isOpeningInNewTab(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const isAppleDevice = isApple();\n  if (isAppleDevice && !event.metaKey) return false;\n  if (!isAppleDevice && !event.ctrlKey) return false;\n  const localName = element.localName;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isDownloadingEvent(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const localName = element.localName;\n  if (!event.altKey) return false;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isComposingEvent(event) {\n  return event.nativeEvent?.isComposing ?? event.isComposing;\n}\n\n// src/get-by-id.ts\nvar defaultItemToId = (v) => v.id;\nfunction itemById(v, id, itemToId = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id);\n}\nfunction indexOfId(v, id, itemToId = defaultItemToId) {\n  const item = itemById(v, id, itemToId);\n  return item ? v.indexOf(item) : -1;\n}\nfunction nextById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);\n  return v[idx];\n}\nfunction prevById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  if (idx === -1) return loop ? v[v.length - 1] : null;\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);\n  return v[idx];\n}\n\n// src/sanitize.ts\nvar sanitize = (str) => str.split(\"\").map((char) => {\n  const code = char.charCodeAt(0);\n  if (code > 0 && code < 128) return char;\n  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\");\n  return \"\";\n}).join(\"\").trim();\n\n// src/get-by-text.ts\nvar getValueText = (item) => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\");\nvar match = (valueText, query2) => valueText.trim().toLowerCase().startsWith(query2.toLowerCase());\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nfunction getByText(v, text, currentId, itemToId = defaultItemToId) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;\n  let items = currentId ? wrap(v, index) : v;\n  const isSingleKey = text.length === 1;\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId);\n  }\n  return items.find((item) => match(getValueText(item), text));\n}\n\n// src/get-by-typeahead.ts\nfunction getByTypeaheadImpl(_items, options) {\n  const { state, activeId, key, timeout = 350, itemToId } = options;\n  const search = state.keysSoFar + key;\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const query2 = isRepeated ? search[0] : search;\n  let items = _items.slice();\n  const next = getByText(items, query2, activeId, itemToId);\n  function cleanup() {\n    clearTimeout(state.timer);\n    state.timer = -1;\n  }\n  function update(value) {\n    state.keysSoFar = value;\n    cleanup();\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\");\n        cleanup();\n      }, timeout);\n    }\n  }\n  update(search);\n  return next;\n}\nvar getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent\n});\nfunction isValidTypeaheadEvent(event) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;\n}\n\n// src/get-computed-style.ts\nvar styleCache = /* @__PURE__ */ new WeakMap();\nfunction getComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\n\n// src/get-parent-node.ts\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node)\n  );\n  return isShadowRoot(result) ? result.host : result;\n}\n\n// src/get-scroll-position.ts\nfunction getScrollPosition(element) {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop };\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY };\n}\n\n// src/tabbable.ts\nvar isHTMLElement2 = (element) => typeof element === \"object\" && element !== null && element.nodeType === 1;\nvar isFrame = (element) => isHTMLElement2(element) && element.tagName === \"IFRAME\";\nfunction isVisible(el) {\n  if (!isHTMLElement2(el)) return false;\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;\n}\nfunction hasNegativeTabIndex(element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10);\n  return tabIndex < 0;\n}\nvar focusableSelector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type\";\nvar getFocusables = (container, includeContainer = false) => {\n  if (!container) return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const include = includeContainer == true || includeContainer == \"if-empty\" && elements.length === 0;\n  if (include && isHTMLElement2(container) && isFocusable(container)) {\n    elements.unshift(container);\n  }\n  const focusableElements = elements.filter(isFocusable);\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      focusableElements.splice(i, 1, ...getFocusables(frameBody));\n    }\n  });\n  return focusableElements;\n};\nfunction isFocusable(element) {\n  if (!element || element.closest(\"[inert]\")) return false;\n  return element.matches(focusableSelector) && isVisible(element);\n}\nfunction getFirstFocusable(container, includeContainer) {\n  const [first] = getFocusables(container, includeContainer);\n  return first || null;\n}\nfunction getTabbables(container, includeContainer) {\n  if (!container) return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const tabbableElements = elements.filter(isTabbable);\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container);\n  }\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      const allFrameTabbable = getTabbables(frameBody);\n      tabbableElements.splice(i, 1, ...allFrameTabbable);\n    }\n  });\n  if (!tabbableElements.length && includeContainer) {\n    return elements;\n  }\n  return tabbableElements;\n}\nfunction isTabbable(el) {\n  if (el != null && el.tabIndex > 0) return true;\n  return isFocusable(el) && !hasNegativeTabIndex(el);\n}\nfunction getFirstTabbable(container, includeContainer) {\n  const [first] = getTabbables(container, includeContainer);\n  return first || null;\n}\nfunction getLastTabbable(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  return elements[elements.length - 1] || null;\n}\nfunction getTabbableEdges(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  const first = elements[0] || null;\n  const last = elements[elements.length - 1] || null;\n  return [first, last];\n}\nfunction getNextTabbable(container, current) {\n  const tabbables = getTabbables(container);\n  const doc = container?.ownerDocument || document;\n  const currentElement = current ?? doc.activeElement;\n  if (!currentElement) return null;\n  const index = tabbables.indexOf(currentElement);\n  return tabbables[index + 1] || null;\n}\n\n// src/initial-focus.ts\nfunction getInitialFocus(options) {\n  const { root, getInitialEl, filter, enabled = true } = options;\n  if (!enabled) return;\n  let node = null;\n  node || (node = typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl);\n  node || (node = root?.querySelector(\"[data-autofocus],[autofocus]\"));\n  if (!node) {\n    const tabbables = getTabbables(root);\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0];\n  }\n  return node || root || void 0;\n}\nfunction isValidTabEvent(event) {\n  const container = event.currentTarget;\n  if (!container) return false;\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container);\n  const doc = container.ownerDocument || document;\n  if (doc.activeElement === firstTabbable && event.shiftKey) return false;\n  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;\n  if (!firstTabbable && !lastTabbable) return false;\n  return true;\n}\n\n// src/is-editable-element.ts\nfunction isEditableElement(el) {\n  if (el == null || !isHTMLElement(el)) {\n    return false;\n  }\n  try {\n    const win = getWindow(el);\n    return el instanceof win.HTMLInputElement && el.selectionStart != null || /(textarea|select)/.test(el.localName) || el.isContentEditable;\n  } catch {\n    return false;\n  }\n}\n\n// src/is-hidden-element.ts\nfunction isHiddenElement(node) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true;\n  return node.hidden;\n}\n\n// src/is-overflow-element.ts\nvar OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;\nfunction isOverflowElement(el) {\n  const win = getWindow(el);\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display);\n}\n\n// src/raf.ts\nfunction nextTick(fn) {\n  const set2 = /* @__PURE__ */ new Set();\n  function raf2(fn2) {\n    const id = globalThis.requestAnimationFrame(fn2);\n    set2.add(() => globalThis.cancelAnimationFrame(id));\n  }\n  raf2(() => raf2(fn));\n  return function cleanup() {\n    set2.forEach((fn2) => fn2());\n  };\n}\nfunction raf(fn) {\n  const id = globalThis.requestAnimationFrame(fn);\n  return () => {\n    globalThis.cancelAnimationFrame(id);\n  };\n}\n\n// src/observe-attributes.ts\nfunction observeAttributesImpl(node, options) {\n  if (!node) return;\n  const { attributes, callback: fn } = options;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change);\n      }\n    }\n  });\n  obs.observe(node, { attributes: true, attributeFilter: attributes });\n  return () => obs.disconnect();\n}\nfunction observeAttributes(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups2 = [];\n  cleanups2.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups2.push(observeAttributesImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups2.forEach((fn) => fn?.());\n  };\n}\n\n// src/observe-children.ts\nfunction observeChildrenImpl(node, options) {\n  const { callback: fn } = options;\n  if (!node) return;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(fn);\n  obs.observe(node, { childList: true, subtree: true });\n  return () => obs.disconnect();\n}\nfunction observeChildren(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups2 = [];\n  cleanups2.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups2.push(observeChildrenImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups2.forEach((fn) => fn?.());\n  };\n}\n\n// src/overflow.ts\nfunction getNearestOverflowAncestor(el) {\n  const parentNode = getParentNode(el);\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(el, list = []) {\n  const scrollableAncestor = getNearestOverflowAncestor(el);\n  const isBody = scrollableAncestor === el.ownerDocument.body;\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));\n}\nvar getRect = (el) => {\n  if (isHTMLElement(el)) {\n    return el.getBoundingClientRect();\n  }\n  if (isVisualViewport(el)) {\n    return { top: 0, left: 0, bottom: el.height, right: el.width };\n  }\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth };\n};\nfunction isInView(el, ancestor) {\n  if (!isHTMLElement(el)) return true;\n  const ancestorRect = getRect(ancestor);\n  const elRect = el.getBoundingClientRect();\n  return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;\n}\n\n// src/proxy-tab-focus.ts\nfunction proxyTabFocusImpl(container, options = {}) {\n  const { triggerElement, onFocus } = options;\n  const doc = container?.ownerDocument || document;\n  const body = doc.body;\n  function onKeyDown(event) {\n    if (event.key !== \"Tab\") return;\n    let elementToFocus = null;\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);\n    const noTabbableElements = !firstTabbable && !lastTabbable;\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement;\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      elementToFocus = firstTabbable;\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      elementToFocus = getNextTabbable(body, triggerElement);\n    }\n    if (!elementToFocus) return;\n    event.preventDefault();\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus);\n    } else {\n      elementToFocus.focus();\n    }\n  }\n  doc?.addEventListener(\"keydown\", onKeyDown, true);\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true);\n  };\n}\nfunction proxyTabFocus(container, options) {\n  const { defer, triggerElement, ...restOptions } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups2 = [];\n  cleanups2.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container;\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement;\n      cleanups2.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));\n    })\n  );\n  return () => {\n    cleanups2.forEach((fn) => fn?.());\n  };\n}\n\n// src/query.ts\nfunction queryAll(root, selector) {\n  return Array.from(root?.querySelectorAll(selector) ?? []);\n}\nfunction query(root, selector) {\n  return root?.querySelector(selector) ?? null;\n}\n\n// src/scope.ts\nfunction createScope(methods) {\n  const dom = {\n    getRootNode: (ctx) => ctx.getRootNode?.() ?? document,\n    getDoc: (ctx) => getDocument(dom.getRootNode(ctx)),\n    getWin: (ctx) => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx) => getActiveElement(dom.getRootNode(ctx)),\n    isActiveElement: (ctx, elem) => elem === dom.getActiveElement(ctx),\n    getById: (ctx, id) => dom.getRootNode(ctx).getElementById(id),\n    setValue: (elem, value) => {\n      if (elem == null || value == null) return;\n      const valueAsString = value.toString();\n      if (elem.value === valueAsString) return;\n      elem.value = value.toString();\n    }\n  };\n  return { ...dom, ...methods };\n}\n\n// src/scroll-into-view.ts\nfunction isScrollable(el) {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;\n}\nfunction scrollIntoView(el, options) {\n  const { rootEl, ...scrollOptions } = options || {};\n  if (!el || !rootEl) {\n    return;\n  }\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return;\n  }\n  el.scrollIntoView(scrollOptions);\n}\n\n// src/set.ts\nvar cleanups = /* @__PURE__ */ new WeakMap();\nfunction set(element, key, setup) {\n  if (!cleanups.has(element)) {\n    cleanups.set(element, /* @__PURE__ */ new Map());\n  }\n  const elementCleanups = cleanups.get(element);\n  const prevCleanup = elementCleanups.get(key);\n  if (!prevCleanup) {\n    elementCleanups.set(key, setup());\n    return () => {\n      elementCleanups.get(key)?.();\n      elementCleanups.delete(key);\n    };\n  }\n  const cleanup = setup();\n  const nextCleanup = () => {\n    cleanup();\n    prevCleanup();\n    elementCleanups.delete(key);\n  };\n  elementCleanups.set(key, nextCleanup);\n  return () => {\n    const isCurrent = elementCleanups.get(key) === nextCleanup;\n    if (!isCurrent) return;\n    cleanup();\n    elementCleanups.set(key, prevCleanup);\n  };\n}\nfunction setAttribute(element, attr, value) {\n  const setup = () => {\n    const previousValue = element.getAttribute(attr);\n    element.setAttribute(attr, value);\n    return () => {\n      if (previousValue == null) {\n        element.removeAttribute(attr);\n      } else {\n        element.setAttribute(attr, previousValue);\n      }\n    };\n  };\n  return set(element, attr, setup);\n}\nfunction setProperty(element, property, value) {\n  const setup = () => {\n    const exists = property in element;\n    const previousValue = element[property];\n    element[property] = value;\n    return () => {\n      if (!exists) {\n        delete element[property];\n      } else {\n        element[property] = previousValue;\n      }\n    };\n  };\n  return set(element, property, setup);\n}\nfunction setStyle(element, style) {\n  if (!element) return () => {\n  };\n  const setup = () => {\n    const prevStyle = element.style.cssText;\n    Object.assign(element.style, style);\n    return () => {\n      element.style.cssText = prevStyle;\n    };\n  };\n  return set(element, \"style\", setup);\n}\n\n// src/visually-hidden.ts\nvar visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n};\n\n// src/wait-for.ts\nvar fps = 1e3 / 60;\nfunction waitForElement(query2, cb) {\n  const el = query2();\n  if (isHTMLElement(el) && el.isConnected) {\n    cb(el);\n    return () => void 0;\n  } else {\n    const timerId = setInterval(() => {\n      const el2 = query2();\n      if (isHTMLElement(el2) && el2.isConnected) {\n        cb(el2);\n        clearInterval(timerId);\n      }\n    }, fps);\n    return () => clearInterval(timerId);\n  }\n}\nfunction waitForElements(queries, cb) {\n  const cleanups2 = [];\n  queries?.forEach((query2) => {\n    const clean = waitForElement(query2, cb);\n    cleanups2.push(clean);\n  });\n  return () => {\n    cleanups2.forEach((fn) => fn());\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHphZy1qcytkb20tcXVlcnlAMC43My4xL25vZGVfbW9kdWxlcy9AemFnLWpzL2RvbS1xdWVyeS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGdEQUFnRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsNkNBQTZDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMENBQTBDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQiwrQ0FBK0M7QUFDckU7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUNBQXlDO0FBQ3hGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFb2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2Fhcy11aS1uZXh0anMtbGFuZGluZy1wYWdlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B6YWctanMrZG9tLXF1ZXJ5QDAuNzMuMS9ub2RlX21vZHVsZXMvQHphZy1qcy9kb20tcXVlcnkvZGlzdC9pbmRleC5tanM/NTJjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvYXR0cnMudHNcbnZhciBkYXRhQXR0ciA9IChndWFyZCkgPT4gZ3VhcmQgPyBcIlwiIDogdm9pZCAwO1xudmFyIGFyaWFBdHRyID0gKGd1YXJkKSA9PiBndWFyZCA/IFwidHJ1ZVwiIDogdm9pZCAwO1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgTUFYX1pfSU5ERVggPSAyMTQ3NDgzNjQ3O1xuXG4vLyBzcmMvaXMudHNcbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbnZhciBpc09iamVjdCA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsO1xudmFyIGlzSFRNTEVsZW1lbnQgPSAoZWwpID0+IGlzT2JqZWN0KGVsKSAmJiBlbC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHR5cGVvZiBlbC5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIjtcbnZhciBpc0RvY3VtZW50ID0gKGVsKSA9PiBpc09iamVjdChlbCkgJiYgZWwubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREU7XG52YXIgaXNXaW5kb3cgPSAoZWwpID0+IGlzT2JqZWN0KGVsKSAmJiBlbCA9PT0gZWwud2luZG93O1xudmFyIGlzVmlzdWFsVmlld3BvcnQgPSAoZWwpID0+IGlzT2JqZWN0KGVsKSAmJiBlbC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlZpc3VhbFZpZXdwb3J0XCI7XG52YXIgZ2V0Tm9kZU5hbWUgPSAobm9kZSkgPT4ge1xuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSkgcmV0dXJuIG5vZGUubG9jYWxOYW1lIHx8IFwiXCI7XG4gIHJldHVybiBcIiNkb2N1bWVudFwiO1xufTtcbmZ1bmN0aW9uIGlzUm9vdEVsZW1lbnQobm9kZSkge1xuICByZXR1cm4gW1wiaHRtbFwiLCBcImJvZHlcIiwgXCIjZG9jdW1lbnRcIl0uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxudmFyIGlzTm9kZSA9IChlbCkgPT4gaXNPYmplY3QoZWwpICYmIGVsLm5vZGVUeXBlICE9PSB2b2lkIDA7XG52YXIgaXNTaGFkb3dSb290ID0gKGVsKSA9PiBpc05vZGUoZWwpICYmIGVsLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIFwiaG9zdFwiIGluIGVsO1xuXG4vLyBzcmMvY29udGFpbnMudHNcbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXNIVE1MRWxlbWVudChwYXJlbnQpIHx8ICFpc0hUTUxFbGVtZW50KGNoaWxkKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gcGFyZW50ID09PSBjaGlsZCB8fCBwYXJlbnQuY29udGFpbnMoY2hpbGQpO1xufVxuXG4vLyBzcmMvZW52LnRzXG5mdW5jdGlvbiBnZXREb2N1bWVudChlbCkge1xuICBpZiAoaXNEb2N1bWVudChlbCkpIHJldHVybiBlbDtcbiAgaWYgKGlzV2luZG93KGVsKSkgcmV0dXJuIGVsLmRvY3VtZW50O1xuICByZXR1cm4gZWw/Lm93bmVyRG9jdW1lbnQgPz8gZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGdldERvY3VtZW50KGVsKS5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3coZWwpIHtcbiAgaWYgKGlzU2hhZG93Um9vdChlbCkpIHJldHVybiBnZXRXaW5kb3coZWwuaG9zdCk7XG4gIGlmIChpc0RvY3VtZW50KGVsKSkgcmV0dXJuIGVsLmRlZmF1bHRWaWV3ID8/IHdpbmRvdztcbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWwpKSByZXR1cm4gZWwub3duZXJEb2N1bWVudD8uZGVmYXVsdFZpZXcgPz8gd2luZG93O1xuICByZXR1cm4gd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChyb290Tm9kZSkge1xuICBsZXQgYWN0aXZlRWxlbWVudCA9IHJvb3ROb2RlLmFjdGl2ZUVsZW1lbnQ7XG4gIHdoaWxlIChhY3RpdmVFbGVtZW50Py5zaGFkb3dSb290KSB7XG4gICAgY29uc3QgZWwgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgPT09IGFjdGl2ZUVsZW1lbnQpIGJyZWFrO1xuICAgIGVsc2UgYWN0aXZlRWxlbWVudCA9IGVsO1xuICB9XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufVxuXG4vLyBzcmMvZGF0YS11cmwudHNcbmZ1bmN0aW9uIGdldERhdGFVcmwoc3ZnLCBvcHRzKSB7XG4gIGNvbnN0IHsgdHlwZSwgcXVhbGl0eSA9IDAuOTIgfSA9IG9wdHM7XG4gIGlmICghc3ZnKSB0aHJvdyBuZXcgRXJyb3IoXCJbZ2V0LWRhdGEtdXJsXTogY291bGQgbm90IGZpbmQgdGhlIHN2ZyBlbGVtZW50XCIpO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc3ZnKTtcbiAgY29uc3QgZG9jID0gd2luLmRvY3VtZW50O1xuICBjb25zdCBzZXJpYWxpemVyID0gbmV3IHdpbi5YTUxTZXJpYWxpemVyKCk7XG4gIGNvbnN0IHNvdXJjZSA9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgc3RhbmRhbG9uZT1cIm5vXCI/PlxcclxcbicgKyBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zyk7XG4gIGNvbnN0IHN2Z1N0cmluZyA9IFwiZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsXCIgKyBlbmNvZGVVUklDb21wb25lbnQoc291cmNlKTtcbiAgaWYgKHR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdmdTdHJpbmcpO1xuICB9XG4gIGNvbnN0IHN2Z0JvdW5kcyA9IHN2Zy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZHByID0gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgY29uc3QgY2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIGNvbnN0IGltYWdlID0gbmV3IHdpbi5JbWFnZSgpO1xuICBpbWFnZS5zcmMgPSBzdmdTdHJpbmc7XG4gIGNhbnZhcy53aWR0aCA9IHN2Z0JvdW5kcy53aWR0aCAqIGRwcjtcbiAgY2FudmFzLmhlaWdodCA9IHN2Z0JvdW5kcy5oZWlnaHQgKiBkcHI7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjb250ZXh0LnNjYWxlKGRwciwgZHByKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgaW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgcmVzb2x2ZShjYW52YXMudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLy8gc3JjL3BsYXRmb3JtLnRzXG52YXIgaXNEb20gPSAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgY29uc3QgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgcmV0dXJuIGFnZW50Py5wbGF0Zm9ybSA/PyBuYXZpZ2F0b3IucGxhdGZvcm07XG59XG52YXIgcHQgPSAodikgPT4gaXNEb20oKSAmJiB2LnRlc3QoZ2V0UGxhdGZvcm0oKSk7XG52YXIgdWEgPSAodikgPT4gaXNEb20oKSAmJiB2LnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgdm4gPSAodikgPT4gaXNEb20oKSAmJiB2LnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG52YXIgaXNUb3VjaERldmljZSA9ICgpID0+IGlzRG9tKCkgJiYgISFuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG52YXIgaXNNYWMgPSAoKSA9PiBwdCgvXk1hYy8pO1xudmFyIGlzU2FmYXJpID0gKCkgPT4gaXNBcHBsZSgpICYmIHZuKC9hcHBsZS9pKTtcbnZhciBpc0ZpcmVmb3ggPSAoKSA9PiB1YSgvZmlyZWZveFxcLy9pKTtcbnZhciBpc0FwcGxlID0gKCkgPT4gcHQoL21hY3xpcGhvbmV8aXBhZHxpcG9kL2kpO1xudmFyIGlzSW9zID0gKCkgPT4gcHQoL2lQKGhvbmV8YWR8b2QpfGlPUy8pO1xudmFyIGlzV2ViS2l0ID0gKCkgPT4gdWEoL0FwcGxlV2ViS2l0Lyk7XG52YXIgaXNNb2RLZXkgPSAoZXZlbnQpID0+IGlzQXBwbGUoKSA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xuXG4vLyBzcmMvZXZlbnQudHNcbmZ1bmN0aW9uIGdldEJlZm9yZUlucHV0VmFsdWUoZXZlbnQpIHtcbiAgY29uc3QgeyBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kLCB2YWx1ZSB9ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgcmV0dXJuIHZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KSArIGV2ZW50LmRhdGEgKyB2YWx1ZS5zbGljZShzZWxlY3Rpb25FbmQpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9zZWRQYXRoKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5jb21wb3NlZFBhdGg/LigpID8/IGV2ZW50Lm5hdGl2ZUV2ZW50Py5jb21wb3NlZFBhdGg/LigpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpIHtcbiAgY29uc3QgY29tcG9zZWRQYXRoID0gZ2V0Q29tcG9zZWRQYXRoKGV2ZW50KTtcbiAgcmV0dXJuIGNvbXBvc2VkUGF0aD8uWzBdID8/IGV2ZW50LnRhcmdldDtcbn1cbnZhciBpc1NlbGZUYXJnZXQgPSAoZXZlbnQpID0+IHtcbiAgcmV0dXJuIGNvbnRhaW5zKGV2ZW50LmN1cnJlbnRUYXJnZXQsIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSk7XG59O1xuZnVuY3Rpb24gaXNPcGVuaW5nSW5OZXdUYWIoZXZlbnQpIHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGlmICghZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBpc0FwcGxlRGV2aWNlID0gaXNBcHBsZSgpO1xuICBpZiAoaXNBcHBsZURldmljZSAmJiAhZXZlbnQubWV0YUtleSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWlzQXBwbGVEZXZpY2UgJiYgIWV2ZW50LmN0cmxLZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbG9jYWxOYW1lID0gZWxlbWVudC5sb2NhbE5hbWU7XG4gIGlmIChsb2NhbE5hbWUgPT09IFwiYVwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGxvY2FsTmFtZSA9PT0gXCJidXR0b25cIiAmJiBlbGVtZW50LnR5cGUgPT09IFwic3VibWl0XCIpIHJldHVybiB0cnVlO1xuICBpZiAobG9jYWxOYW1lID09PSBcImlucHV0XCIgJiYgZWxlbWVudC50eXBlID09PSBcInN1Ym1pdFwiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNEb3dubG9hZGluZ0V2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBpZiAoIWVsZW1lbnQpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbG9jYWxOYW1lID0gZWxlbWVudC5sb2NhbE5hbWU7XG4gIGlmICghZXZlbnQuYWx0S2V5KSByZXR1cm4gZmFsc2U7XG4gIGlmIChsb2NhbE5hbWUgPT09IFwiYVwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGxvY2FsTmFtZSA9PT0gXCJidXR0b25cIiAmJiBlbGVtZW50LnR5cGUgPT09IFwic3VibWl0XCIpIHJldHVybiB0cnVlO1xuICBpZiAobG9jYWxOYW1lID09PSBcImlucHV0XCIgJiYgZWxlbWVudC50eXBlID09PSBcInN1Ym1pdFwiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb21wb3NpbmdFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQubmF0aXZlRXZlbnQ/LmlzQ29tcG9zaW5nID8/IGV2ZW50LmlzQ29tcG9zaW5nO1xufVxuXG4vLyBzcmMvZ2V0LWJ5LWlkLnRzXG52YXIgZGVmYXVsdEl0ZW1Ub0lkID0gKHYpID0+IHYuaWQ7XG5mdW5jdGlvbiBpdGVtQnlJZCh2LCBpZCwgaXRlbVRvSWQgPSBkZWZhdWx0SXRlbVRvSWQpIHtcbiAgcmV0dXJuIHYuZmluZCgoaXRlbSkgPT4gaXRlbVRvSWQoaXRlbSkgPT09IGlkKTtcbn1cbmZ1bmN0aW9uIGluZGV4T2ZJZCh2LCBpZCwgaXRlbVRvSWQgPSBkZWZhdWx0SXRlbVRvSWQpIHtcbiAgY29uc3QgaXRlbSA9IGl0ZW1CeUlkKHYsIGlkLCBpdGVtVG9JZCk7XG4gIHJldHVybiBpdGVtID8gdi5pbmRleE9mKGl0ZW0pIDogLTE7XG59XG5mdW5jdGlvbiBuZXh0QnlJZCh2LCBpZCwgbG9vcCA9IHRydWUpIHtcbiAgbGV0IGlkeCA9IGluZGV4T2ZJZCh2LCBpZCk7XG4gIGlkeCA9IGxvb3AgPyAoaWR4ICsgMSkgJSB2Lmxlbmd0aCA6IE1hdGgubWluKGlkeCArIDEsIHYubGVuZ3RoIC0gMSk7XG4gIHJldHVybiB2W2lkeF07XG59XG5mdW5jdGlvbiBwcmV2QnlJZCh2LCBpZCwgbG9vcCA9IHRydWUpIHtcbiAgbGV0IGlkeCA9IGluZGV4T2ZJZCh2LCBpZCk7XG4gIGlmIChpZHggPT09IC0xKSByZXR1cm4gbG9vcCA/IHZbdi5sZW5ndGggLSAxXSA6IG51bGw7XG4gIGlkeCA9IGxvb3AgPyAoaWR4IC0gMSArIHYubGVuZ3RoKSAlIHYubGVuZ3RoIDogTWF0aC5tYXgoMCwgaWR4IC0gMSk7XG4gIHJldHVybiB2W2lkeF07XG59XG5cbi8vIHNyYy9zYW5pdGl6ZS50c1xudmFyIHNhbml0aXplID0gKHN0cikgPT4gc3RyLnNwbGl0KFwiXCIpLm1hcCgoY2hhcikgPT4ge1xuICBjb25zdCBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICBpZiAoY29kZSA+IDAgJiYgY29kZSA8IDEyOCkgcmV0dXJuIGNoYXI7XG4gIGlmIChjb2RlID49IDEyOCAmJiBjb2RlIDw9IDI1NSkgcmV0dXJuIGAveCR7Y29kZS50b1N0cmluZygxNil9YC5yZXBsYWNlKFwiL1wiLCBcIlxcXFxcIik7XG4gIHJldHVybiBcIlwiO1xufSkuam9pbihcIlwiKS50cmltKCk7XG5cbi8vIHNyYy9nZXQtYnktdGV4dC50c1xudmFyIGdldFZhbHVlVGV4dCA9IChpdGVtKSA9PiBzYW5pdGl6ZShpdGVtLmRhdGFzZXQudmFsdWV0ZXh0ID8/IGl0ZW0udGV4dENvbnRlbnQgPz8gXCJcIik7XG52YXIgbWF0Y2ggPSAodmFsdWVUZXh0LCBxdWVyeTIpID0+IHZhbHVlVGV4dC50cmltKCkudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHF1ZXJ5Mi50b0xvd2VyQ2FzZSgpKTtcbnZhciB3cmFwID0gKHYsIGlkeCkgPT4ge1xuICByZXR1cm4gdi5tYXAoKF8sIGluZGV4KSA9PiB2WyhNYXRoLm1heChpZHgsIDApICsgaW5kZXgpICUgdi5sZW5ndGhdKTtcbn07XG5mdW5jdGlvbiBnZXRCeVRleHQodiwgdGV4dCwgY3VycmVudElkLCBpdGVtVG9JZCA9IGRlZmF1bHRJdGVtVG9JZCkge1xuICBjb25zdCBpbmRleCA9IGN1cnJlbnRJZCA/IGluZGV4T2ZJZCh2LCBjdXJyZW50SWQsIGl0ZW1Ub0lkKSA6IC0xO1xuICBsZXQgaXRlbXMgPSBjdXJyZW50SWQgPyB3cmFwKHYsIGluZGV4KSA6IHY7XG4gIGNvbnN0IGlzU2luZ2xlS2V5ID0gdGV4dC5sZW5ndGggPT09IDE7XG4gIGlmIChpc1NpbmdsZUtleSkge1xuICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtVG9JZChpdGVtKSAhPT0gY3VycmVudElkKTtcbiAgfVxuICByZXR1cm4gaXRlbXMuZmluZCgoaXRlbSkgPT4gbWF0Y2goZ2V0VmFsdWVUZXh0KGl0ZW0pLCB0ZXh0KSk7XG59XG5cbi8vIHNyYy9nZXQtYnktdHlwZWFoZWFkLnRzXG5mdW5jdGlvbiBnZXRCeVR5cGVhaGVhZEltcGwoX2l0ZW1zLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgc3RhdGUsIGFjdGl2ZUlkLCBrZXksIHRpbWVvdXQgPSAzNTAsIGl0ZW1Ub0lkIH0gPSBvcHRpb25zO1xuICBjb25zdCBzZWFyY2ggPSBzdGF0ZS5rZXlzU29GYXIgKyBrZXk7XG4gIGNvbnN0IGlzUmVwZWF0ZWQgPSBzZWFyY2gubGVuZ3RoID4gMSAmJiBBcnJheS5mcm9tKHNlYXJjaCkuZXZlcnkoKGNoYXIpID0+IGNoYXIgPT09IHNlYXJjaFswXSk7XG4gIGNvbnN0IHF1ZXJ5MiA9IGlzUmVwZWF0ZWQgPyBzZWFyY2hbMF0gOiBzZWFyY2g7XG4gIGxldCBpdGVtcyA9IF9pdGVtcy5zbGljZSgpO1xuICBjb25zdCBuZXh0ID0gZ2V0QnlUZXh0KGl0ZW1zLCBxdWVyeTIsIGFjdGl2ZUlkLCBpdGVtVG9JZCk7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVyKTtcbiAgICBzdGF0ZS50aW1lciA9IC0xO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSkge1xuICAgIHN0YXRlLmtleXNTb0ZhciA9IHZhbHVlO1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAodmFsdWUgIT09IFwiXCIpIHtcbiAgICAgIHN0YXRlLnRpbWVyID0gK3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB1cGRhdGUoXCJcIik7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoc2VhcmNoKTtcbiAgcmV0dXJuIG5leHQ7XG59XG52YXIgZ2V0QnlUeXBlYWhlYWQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbihnZXRCeVR5cGVhaGVhZEltcGwsIHtcbiAgZGVmYXVsdE9wdGlvbnM6IHsga2V5c1NvRmFyOiBcIlwiLCB0aW1lcjogLTEgfSxcbiAgaXNWYWxpZEV2ZW50OiBpc1ZhbGlkVHlwZWFoZWFkRXZlbnRcbn0pO1xuZnVuY3Rpb24gaXNWYWxpZFR5cGVhaGVhZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5rZXkubGVuZ3RoID09PSAxICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5tZXRhS2V5O1xufVxuXG4vLyBzcmMvZ2V0LWNvbXB1dGVkLXN0eWxlLnRzXG52YXIgc3R5bGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbCkge1xuICBpZiAoIXN0eWxlQ2FjaGUuaGFzKGVsKSkge1xuICAgIHN0eWxlQ2FjaGUuc2V0KGVsLCBnZXRXaW5kb3coZWwpLmdldENvbXB1dGVkU3R5bGUoZWwpKTtcbiAgfVxuICByZXR1cm4gc3R5bGVDYWNoZS5nZXQoZWwpO1xufVxuXG4vLyBzcmMvZ2V0LXBhcmVudC1ub2RlLnRzXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSBcImh0bWxcIikge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IChcbiAgICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgICBub2RlLmFzc2lnbmVkU2xvdCB8fCAvLyBET00gRWxlbWVudCBkZXRlY3RlZC5cbiAgICBub2RlLnBhcmVudE5vZGUgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZC5cbiAgICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8IC8vIEZhbGxiYWNrLlxuICAgIGdldERvY3VtZW50RWxlbWVudChub2RlKVxuICApO1xuICByZXR1cm4gaXNTaGFkb3dSb290KHJlc3VsdCkgPyByZXN1bHQuaG9zdCA6IHJlc3VsdDtcbn1cblxuLy8gc3JjL2dldC1zY3JvbGwtcG9zaXRpb24udHNcbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4geyBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3AgfTtcbiAgfVxuICByZXR1cm4geyBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbFgsIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxZIH07XG59XG5cbi8vIHNyYy90YWJiYWJsZS50c1xudmFyIGlzSFRNTEVsZW1lbnQyID0gKGVsZW1lbnQpID0+IHR5cGVvZiBlbGVtZW50ID09PSBcIm9iamVjdFwiICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMTtcbnZhciBpc0ZyYW1lID0gKGVsZW1lbnQpID0+IGlzSFRNTEVsZW1lbnQyKGVsZW1lbnQpICYmIGVsZW1lbnQudGFnTmFtZSA9PT0gXCJJRlJBTUVcIjtcbmZ1bmN0aW9uIGlzVmlzaWJsZShlbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQyKGVsKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZWwub2Zmc2V0V2lkdGggPiAwIHx8IGVsLm9mZnNldEhlaWdodCA+IDAgfHwgZWwuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwO1xufVxuZnVuY3Rpb24gaGFzTmVnYXRpdmVUYWJJbmRleChlbGVtZW50KSB7XG4gIGNvbnN0IHRhYkluZGV4ID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSB8fCBcIjBcIiwgMTApO1xuICByZXR1cm4gdGFiSW5kZXggPCAwO1xufVxudmFyIGZvY3VzYWJsZVNlbGVjdG9yID0gXCJpbnB1dDpub3QoW3R5cGU9J2hpZGRlbiddKTpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYVtocmVmXSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgW3RhYmluZGV4XSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCBhcmVhW2hyZWZdLCBhdWRpb1tjb250cm9sc10sIHZpZGVvW2NvbnRyb2xzXSwgW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9J2ZhbHNlJ10pLCBkZXRhaWxzID4gc3VtbWFyeTpmaXJzdC1vZi10eXBlXCI7XG52YXIgZ2V0Rm9jdXNhYmxlcyA9IChjb250YWluZXIsIGluY2x1ZGVDb250YWluZXIgPSBmYWxzZSkgPT4ge1xuICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuIFtdO1xuICBjb25zdCBlbGVtZW50cyA9IEFycmF5LmZyb20oY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlU2VsZWN0b3IpKTtcbiAgY29uc3QgaW5jbHVkZSA9IGluY2x1ZGVDb250YWluZXIgPT0gdHJ1ZSB8fCBpbmNsdWRlQ29udGFpbmVyID09IFwiaWYtZW1wdHlcIiAmJiBlbGVtZW50cy5sZW5ndGggPT09IDA7XG4gIGlmIChpbmNsdWRlICYmIGlzSFRNTEVsZW1lbnQyKGNvbnRhaW5lcikgJiYgaXNGb2N1c2FibGUoY29udGFpbmVyKSkge1xuICAgIGVsZW1lbnRzLnVuc2hpZnQoY29udGFpbmVyKTtcbiAgfVxuICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGVsZW1lbnRzLmZpbHRlcihpc0ZvY3VzYWJsZSk7XG4gIGZvY3VzYWJsZUVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQsIGkpID0+IHtcbiAgICBpZiAoaXNGcmFtZShlbGVtZW50KSAmJiBlbGVtZW50LmNvbnRlbnREb2N1bWVudCkge1xuICAgICAgY29uc3QgZnJhbWVCb2R5ID0gZWxlbWVudC5jb250ZW50RG9jdW1lbnQuYm9keTtcbiAgICAgIGZvY3VzYWJsZUVsZW1lbnRzLnNwbGljZShpLCAxLCAuLi5nZXRGb2N1c2FibGVzKGZyYW1lQm9keSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmb2N1c2FibGVFbGVtZW50cztcbn07XG5mdW5jdGlvbiBpc0ZvY3VzYWJsZShlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCB8fCBlbGVtZW50LmNsb3Nlc3QoXCJbaW5lcnRdXCIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoZm9jdXNhYmxlU2VsZWN0b3IpICYmIGlzVmlzaWJsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0Rm9jdXNhYmxlKGNvbnRhaW5lciwgaW5jbHVkZUNvbnRhaW5lcikge1xuICBjb25zdCBbZmlyc3RdID0gZ2V0Rm9jdXNhYmxlcyhjb250YWluZXIsIGluY2x1ZGVDb250YWluZXIpO1xuICByZXR1cm4gZmlyc3QgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFRhYmJhYmxlcyhjb250YWluZXIsIGluY2x1ZGVDb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHJldHVybiBbXTtcbiAgY29uc3QgZWxlbWVudHMgPSBBcnJheS5mcm9tKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKGZvY3VzYWJsZVNlbGVjdG9yKSk7XG4gIGNvbnN0IHRhYmJhYmxlRWxlbWVudHMgPSBlbGVtZW50cy5maWx0ZXIoaXNUYWJiYWJsZSk7XG4gIGlmIChpbmNsdWRlQ29udGFpbmVyICYmIGlzVGFiYmFibGUoY29udGFpbmVyKSkge1xuICAgIHRhYmJhYmxlRWxlbWVudHMudW5zaGlmdChjb250YWluZXIpO1xuICB9XG4gIHRhYmJhYmxlRWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4ge1xuICAgIGlmIChpc0ZyYW1lKGVsZW1lbnQpICYmIGVsZW1lbnQuY29udGVudERvY3VtZW50KSB7XG4gICAgICBjb25zdCBmcmFtZUJvZHkgPSBlbGVtZW50LmNvbnRlbnREb2N1bWVudC5ib2R5O1xuICAgICAgY29uc3QgYWxsRnJhbWVUYWJiYWJsZSA9IGdldFRhYmJhYmxlcyhmcmFtZUJvZHkpO1xuICAgICAgdGFiYmFibGVFbGVtZW50cy5zcGxpY2UoaSwgMSwgLi4uYWxsRnJhbWVUYWJiYWJsZSk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCF0YWJiYWJsZUVsZW1lbnRzLmxlbmd0aCAmJiBpbmNsdWRlQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9XG4gIHJldHVybiB0YWJiYWJsZUVsZW1lbnRzO1xufVxuZnVuY3Rpb24gaXNUYWJiYWJsZShlbCkge1xuICBpZiAoZWwgIT0gbnVsbCAmJiBlbC50YWJJbmRleCA+IDApIHJldHVybiB0cnVlO1xuICByZXR1cm4gaXNGb2N1c2FibGUoZWwpICYmICFoYXNOZWdhdGl2ZVRhYkluZGV4KGVsKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0VGFiYmFibGUoY29udGFpbmVyLCBpbmNsdWRlQ29udGFpbmVyKSB7XG4gIGNvbnN0IFtmaXJzdF0gPSBnZXRUYWJiYWJsZXMoY29udGFpbmVyLCBpbmNsdWRlQ29udGFpbmVyKTtcbiAgcmV0dXJuIGZpcnN0IHx8IG51bGw7XG59XG5mdW5jdGlvbiBnZXRMYXN0VGFiYmFibGUoY29udGFpbmVyLCBpbmNsdWRlQ29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gZ2V0VGFiYmFibGVzKGNvbnRhaW5lciwgaW5jbHVkZUNvbnRhaW5lcik7XG4gIHJldHVybiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGFiYmFibGVFZGdlcyhjb250YWluZXIsIGluY2x1ZGVDb250YWluZXIpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBnZXRUYWJiYWJsZXMoY29udGFpbmVyLCBpbmNsdWRlQ29udGFpbmVyKTtcbiAgY29uc3QgZmlyc3QgPSBlbGVtZW50c1swXSB8fCBudWxsO1xuICBjb25zdCBsYXN0ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgcmV0dXJuIFtmaXJzdCwgbGFzdF07XG59XG5mdW5jdGlvbiBnZXROZXh0VGFiYmFibGUoY29udGFpbmVyLCBjdXJyZW50KSB7XG4gIGNvbnN0IHRhYmJhYmxlcyA9IGdldFRhYmJhYmxlcyhjb250YWluZXIpO1xuICBjb25zdCBkb2MgPSBjb250YWluZXI/Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIGNvbnN0IGN1cnJlbnRFbGVtZW50ID0gY3VycmVudCA/PyBkb2MuYWN0aXZlRWxlbWVudDtcbiAgaWYgKCFjdXJyZW50RWxlbWVudCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGluZGV4ID0gdGFiYmFibGVzLmluZGV4T2YoY3VycmVudEVsZW1lbnQpO1xuICByZXR1cm4gdGFiYmFibGVzW2luZGV4ICsgMV0gfHwgbnVsbDtcbn1cblxuLy8gc3JjL2luaXRpYWwtZm9jdXMudHNcbmZ1bmN0aW9uIGdldEluaXRpYWxGb2N1cyhvcHRpb25zKSB7XG4gIGNvbnN0IHsgcm9vdCwgZ2V0SW5pdGlhbEVsLCBmaWx0ZXIsIGVuYWJsZWQgPSB0cnVlIH0gPSBvcHRpb25zO1xuICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICBub2RlIHx8IChub2RlID0gdHlwZW9mIGdldEluaXRpYWxFbCA9PT0gXCJmdW5jdGlvblwiID8gZ2V0SW5pdGlhbEVsKCkgOiBnZXRJbml0aWFsRWwpO1xuICBub2RlIHx8IChub2RlID0gcm9vdD8ucXVlcnlTZWxlY3RvcihcIltkYXRhLWF1dG9mb2N1c10sW2F1dG9mb2N1c11cIikpO1xuICBpZiAoIW5vZGUpIHtcbiAgICBjb25zdCB0YWJiYWJsZXMgPSBnZXRUYWJiYWJsZXMocm9vdCk7XG4gICAgbm9kZSA9IGZpbHRlciA/IHRhYmJhYmxlcy5maWx0ZXIoZmlsdGVyKVswXSA6IHRhYmJhYmxlc1swXTtcbiAgfVxuICByZXR1cm4gbm9kZSB8fCByb290IHx8IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUYWJFdmVudChldmVudCkge1xuICBjb25zdCBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBbZmlyc3RUYWJiYWJsZSwgbGFzdFRhYmJhYmxlXSA9IGdldFRhYmJhYmxlRWRnZXMoY29udGFpbmVyKTtcbiAgY29uc3QgZG9jID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIGlmIChkb2MuYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RUYWJiYWJsZSAmJiBldmVudC5zaGlmdEtleSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZG9jLmFjdGl2ZUVsZW1lbnQgPT09IGxhc3RUYWJiYWJsZSAmJiAhZXZlbnQuc2hpZnRLZXkpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFmaXJzdFRhYmJhYmxlICYmICFsYXN0VGFiYmFibGUpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9pcy1lZGl0YWJsZS1lbGVtZW50LnRzXG5mdW5jdGlvbiBpc0VkaXRhYmxlRWxlbWVudChlbCkge1xuICBpZiAoZWwgPT0gbnVsbCB8fCAhaXNIVE1MRWxlbWVudChlbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWwpO1xuICAgIHJldHVybiBlbCBpbnN0YW5jZW9mIHdpbi5IVE1MSW5wdXRFbGVtZW50ICYmIGVsLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwgfHwgLyh0ZXh0YXJlYXxzZWxlY3QpLy50ZXN0KGVsLmxvY2FsTmFtZSkgfHwgZWwuaXNDb250ZW50RWRpdGFibGU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvaXMtaGlkZGVuLWVsZW1lbnQudHNcbmZ1bmN0aW9uIGlzSGlkZGVuRWxlbWVudChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudEVsZW1lbnQgJiYgaXNIaWRkZW5FbGVtZW50KG5vZGUucGFyZW50RWxlbWVudCkpIHJldHVybiB0cnVlO1xuICByZXR1cm4gbm9kZS5oaWRkZW47XG59XG5cbi8vIHNyYy9pcy1vdmVyZmxvdy1lbGVtZW50LnRzXG52YXIgT1ZFUkZMT1dfUkUgPSAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC87XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWwpO1xuICBjb25zdCB7IG92ZXJmbG93LCBvdmVyZmxvd1gsIG92ZXJmbG93WSwgZGlzcGxheSB9ID0gd2luLmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICByZXR1cm4gT1ZFUkZMT1dfUkUudGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIVtcImlubGluZVwiLCBcImNvbnRlbnRzXCJdLmluY2x1ZGVzKGRpc3BsYXkpO1xufVxuXG4vLyBzcmMvcmFmLnRzXG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xuICBjb25zdCBzZXQyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gcmFmMihmbjIpIHtcbiAgICBjb25zdCBpZCA9IGdsb2JhbFRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuMik7XG4gICAgc2V0Mi5hZGQoKCkgPT4gZ2xvYmFsVGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCkpO1xuICB9XG4gIHJhZjIoKCkgPT4gcmFmMihmbikpO1xuICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzZXQyLmZvckVhY2goKGZuMikgPT4gZm4yKCkpO1xuICB9O1xufVxuZnVuY3Rpb24gcmFmKGZuKSB7XG4gIGNvbnN0IGlkID0gZ2xvYmFsVGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGdsb2JhbFRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICB9O1xufVxuXG4vLyBzcmMvb2JzZXJ2ZS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBvYnNlcnZlQXR0cmlidXRlc0ltcGwobm9kZSwgb3B0aW9ucykge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3QgeyBhdHRyaWJ1dGVzLCBjYWxsYmFjazogZm4gfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHdpbiA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIGNvbnN0IG9icyA9IG5ldyB3aW4uTXV0YXRpb25PYnNlcnZlcigoY2hhbmdlcykgPT4ge1xuICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgY2hhbmdlLmF0dHJpYnV0ZU5hbWUgJiYgYXR0cmlidXRlcy5pbmNsdWRlcyhjaGFuZ2UuYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgZm4oY2hhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBvYnMub2JzZXJ2ZShub2RlLCB7IGF0dHJpYnV0ZXM6IHRydWUsIGF0dHJpYnV0ZUZpbHRlcjogYXR0cmlidXRlcyB9KTtcbiAgcmV0dXJuICgpID0+IG9icy5kaXNjb25uZWN0KCk7XG59XG5mdW5jdGlvbiBvYnNlcnZlQXR0cmlidXRlcyhub2RlT3JGbiwgb3B0aW9ucykge1xuICBjb25zdCB7IGRlZmVyIH0gPSBvcHRpb25zO1xuICBjb25zdCBmdW5jID0gZGVmZXIgPyByYWYgOiAodikgPT4gdigpO1xuICBjb25zdCBjbGVhbnVwczIgPSBbXTtcbiAgY2xlYW51cHMyLnB1c2goXG4gICAgZnVuYygoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdHlwZW9mIG5vZGVPckZuID09PSBcImZ1bmN0aW9uXCIgPyBub2RlT3JGbigpIDogbm9kZU9yRm47XG4gICAgICBjbGVhbnVwczIucHVzaChvYnNlcnZlQXR0cmlidXRlc0ltcGwobm9kZSwgb3B0aW9ucykpO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYW51cHMyLmZvckVhY2goKGZuKSA9PiBmbj8uKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvb2JzZXJ2ZS1jaGlsZHJlbi50c1xuZnVuY3Rpb24gb2JzZXJ2ZUNoaWxkcmVuSW1wbChub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgY2FsbGJhY2s6IGZuIH0gPSBvcHRpb25zO1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3Qgd2luID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgY29uc3Qgb2JzID0gbmV3IHdpbi5NdXRhdGlvbk9ic2VydmVyKGZuKTtcbiAgb2JzLm9ic2VydmUobm9kZSwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gIHJldHVybiAoKSA9PiBvYnMuZGlzY29ubmVjdCgpO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZUNoaWxkcmVuKG5vZGVPckZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZGVmZXIgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZ1bmMgPSBkZWZlciA/IHJhZiA6ICh2KSA9PiB2KCk7XG4gIGNvbnN0IGNsZWFudXBzMiA9IFtdO1xuICBjbGVhbnVwczIucHVzaChcbiAgICBmdW5jKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0eXBlb2Ygbm9kZU9yRm4gPT09IFwiZnVuY3Rpb25cIiA/IG5vZGVPckZuKCkgOiBub2RlT3JGbjtcbiAgICAgIGNsZWFudXBzMi5wdXNoKG9ic2VydmVDaGlsZHJlbkltcGwobm9kZSwgb3B0aW9ucykpO1xuICAgIH0pXG4gICk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY2xlYW51cHMyLmZvckVhY2goKGZuKSA9PiBmbj8uKCkpO1xuICB9O1xufVxuXG4vLyBzcmMvb3ZlcmZsb3cudHNcbmZ1bmN0aW9uIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKGVsKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsKTtcbiAgaWYgKGlzUm9vdEVsZW1lbnQocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0RG9jdW1lbnQocGFyZW50Tm9kZSkuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKGVsLCBsaXN0ID0gW10pIHtcbiAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IoZWwpO1xuICBjb25zdCBpc0JvZHkgPSBzY3JvbGxhYmxlQW5jZXN0b3IgPT09IGVsLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KHNjcm9sbGFibGVBbmNlc3Rvcik7XG4gIGlmIChpc0JvZHkpIHtcbiAgICByZXR1cm4gbGlzdC5jb25jYXQod2luLCB3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzT3ZlcmZsb3dFbGVtZW50KHNjcm9sbGFibGVBbmNlc3RvcikgPyBzY3JvbGxhYmxlQW5jZXN0b3IgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSkpO1xufVxudmFyIGdldFJlY3QgPSAoZWwpID0+IHtcbiAgaWYgKGlzSFRNTEVsZW1lbnQoZWwpKSB7XG4gICAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGlmIChpc1Zpc3VhbFZpZXdwb3J0KGVsKSkge1xuICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiBlbC5oZWlnaHQsIHJpZ2h0OiBlbC53aWR0aCB9O1xuICB9XG4gIHJldHVybiB7IHRvcDogMCwgbGVmdDogMCwgYm90dG9tOiBlbC5pbm5lckhlaWdodCwgcmlnaHQ6IGVsLmlubmVyV2lkdGggfTtcbn07XG5mdW5jdGlvbiBpc0luVmlldyhlbCwgYW5jZXN0b3IpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsKSkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IGFuY2VzdG9yUmVjdCA9IGdldFJlY3QoYW5jZXN0b3IpO1xuICBjb25zdCBlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIGVsUmVjdC50b3AgPj0gYW5jZXN0b3JSZWN0LnRvcCAmJiBlbFJlY3QubGVmdCA+PSBhbmNlc3RvclJlY3QubGVmdCAmJiBlbFJlY3QuYm90dG9tIDw9IGFuY2VzdG9yUmVjdC5ib3R0b20gJiYgZWxSZWN0LnJpZ2h0IDw9IGFuY2VzdG9yUmVjdC5yaWdodDtcbn1cblxuLy8gc3JjL3Byb3h5LXRhYi1mb2N1cy50c1xuZnVuY3Rpb24gcHJveHlUYWJGb2N1c0ltcGwoY29udGFpbmVyLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyB0cmlnZ2VyRWxlbWVudCwgb25Gb2N1cyB9ID0gb3B0aW9ucztcbiAgY29uc3QgZG9jID0gY29udGFpbmVyPy5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICBjb25zdCBib2R5ID0gZG9jLmJvZHk7XG4gIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5rZXkgIT09IFwiVGFiXCIpIHJldHVybjtcbiAgICBsZXQgZWxlbWVudFRvRm9jdXMgPSBudWxsO1xuICAgIGNvbnN0IFtmaXJzdFRhYmJhYmxlLCBsYXN0VGFiYmFibGVdID0gZ2V0VGFiYmFibGVFZGdlcyhjb250YWluZXIsIHRydWUpO1xuICAgIGNvbnN0IG5vVGFiYmFibGVFbGVtZW50cyA9ICFmaXJzdFRhYmJhYmxlICYmICFsYXN0VGFiYmFibGU7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIChkb2MuYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RUYWJiYWJsZSB8fCBub1RhYmJhYmxlRWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50VG9Gb2N1cyA9IHRyaWdnZXJFbGVtZW50O1xuICAgIH0gZWxzZSBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGRvYy5hY3RpdmVFbGVtZW50ID09PSB0cmlnZ2VyRWxlbWVudCkge1xuICAgICAgZWxlbWVudFRvRm9jdXMgPSBmaXJzdFRhYmJhYmxlO1xuICAgIH0gZWxzZSBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIChkb2MuYWN0aXZlRWxlbWVudCA9PT0gbGFzdFRhYmJhYmxlIHx8IG5vVGFiYmFibGVFbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRUb0ZvY3VzID0gZ2V0TmV4dFRhYmJhYmxlKGJvZHksIHRyaWdnZXJFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50VG9Gb2N1cykgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKHR5cGVvZiBvbkZvY3VzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9uRm9jdXMoZWxlbWVudFRvRm9jdXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50VG9Gb2N1cy5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBkb2M/LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93biwgdHJ1ZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZG9jPy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24sIHRydWUpO1xuICB9O1xufVxuZnVuY3Rpb24gcHJveHlUYWJGb2N1cyhjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBkZWZlciwgdHJpZ2dlckVsZW1lbnQsIC4uLnJlc3RPcHRpb25zIH0gPSBvcHRpb25zO1xuICBjb25zdCBmdW5jID0gZGVmZXIgPyByYWYgOiAodikgPT4gdigpO1xuICBjb25zdCBjbGVhbnVwczIgPSBbXTtcbiAgY2xlYW51cHMyLnB1c2goXG4gICAgZnVuYygoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdHlwZW9mIGNvbnRhaW5lciA9PT0gXCJmdW5jdGlvblwiID8gY29udGFpbmVyKCkgOiBjb250YWluZXI7XG4gICAgICBjb25zdCB0cmlnZ2VyID0gdHlwZW9mIHRyaWdnZXJFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgPyB0cmlnZ2VyRWxlbWVudCgpIDogdHJpZ2dlckVsZW1lbnQ7XG4gICAgICBjbGVhbnVwczIucHVzaChwcm94eVRhYkZvY3VzSW1wbChub2RlLCB7IHRyaWdnZXJFbGVtZW50OiB0cmlnZ2VyLCAuLi5yZXN0T3B0aW9ucyB9KSk7XG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjbGVhbnVwczIuZm9yRWFjaCgoZm4pID0+IGZuPy4oKSk7XG4gIH07XG59XG5cbi8vIHNyYy9xdWVyeS50c1xuZnVuY3Rpb24gcXVlcnlBbGwocm9vdCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20ocm9vdD8ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgPz8gW10pO1xufVxuZnVuY3Rpb24gcXVlcnkocm9vdCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHJvb3Q/LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8/IG51bGw7XG59XG5cbi8vIHNyYy9zY29wZS50c1xuZnVuY3Rpb24gY3JlYXRlU2NvcGUobWV0aG9kcykge1xuICBjb25zdCBkb20gPSB7XG4gICAgZ2V0Um9vdE5vZGU6IChjdHgpID0+IGN0eC5nZXRSb290Tm9kZT8uKCkgPz8gZG9jdW1lbnQsXG4gICAgZ2V0RG9jOiAoY3R4KSA9PiBnZXREb2N1bWVudChkb20uZ2V0Um9vdE5vZGUoY3R4KSksXG4gICAgZ2V0V2luOiAoY3R4KSA9PiBkb20uZ2V0RG9jKGN0eCkuZGVmYXVsdFZpZXcgPz8gd2luZG93LFxuICAgIGdldEFjdGl2ZUVsZW1lbnQ6IChjdHgpID0+IGdldEFjdGl2ZUVsZW1lbnQoZG9tLmdldFJvb3ROb2RlKGN0eCkpLFxuICAgIGlzQWN0aXZlRWxlbWVudDogKGN0eCwgZWxlbSkgPT4gZWxlbSA9PT0gZG9tLmdldEFjdGl2ZUVsZW1lbnQoY3R4KSxcbiAgICBnZXRCeUlkOiAoY3R4LCBpZCkgPT4gZG9tLmdldFJvb3ROb2RlKGN0eCkuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgIHNldFZhbHVlOiAoZWxlbSwgdmFsdWUpID0+IHtcbiAgICAgIGlmIChlbGVtID09IG51bGwgfHwgdmFsdWUgPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgY29uc3QgdmFsdWVBc1N0cmluZyA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoZWxlbS52YWx1ZSA9PT0gdmFsdWVBc1N0cmluZykgcmV0dXJuO1xuICAgICAgZWxlbS52YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4geyAuLi5kb20sIC4uLm1ldGhvZHMgfTtcbn1cblxuLy8gc3JjL3Njcm9sbC1pbnRvLXZpZXcudHNcbmZ1bmN0aW9uIGlzU2Nyb2xsYWJsZShlbCkge1xuICByZXR1cm4gZWwuc2Nyb2xsSGVpZ2h0ID4gZWwuY2xpZW50SGVpZ2h0IHx8IGVsLnNjcm9sbFdpZHRoID4gZWwuY2xpZW50V2lkdGg7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbCwgb3B0aW9ucykge1xuICBjb25zdCB7IHJvb3RFbCwgLi4uc2Nyb2xsT3B0aW9ucyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFlbCB8fCAhcm9vdEVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghaXNPdmVyZmxvd0VsZW1lbnQocm9vdEVsKSB8fCAhaXNTY3JvbGxhYmxlKHJvb3RFbCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWwuc2Nyb2xsSW50b1ZpZXcoc2Nyb2xsT3B0aW9ucyk7XG59XG5cbi8vIHNyYy9zZXQudHNcbnZhciBjbGVhbnVwcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc2V0KGVsZW1lbnQsIGtleSwgc2V0dXApIHtcbiAgaWYgKCFjbGVhbnVwcy5oYXMoZWxlbWVudCkpIHtcbiAgICBjbGVhbnVwcy5zZXQoZWxlbWVudCwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH1cbiAgY29uc3QgZWxlbWVudENsZWFudXBzID0gY2xlYW51cHMuZ2V0KGVsZW1lbnQpO1xuICBjb25zdCBwcmV2Q2xlYW51cCA9IGVsZW1lbnRDbGVhbnVwcy5nZXQoa2V5KTtcbiAgaWYgKCFwcmV2Q2xlYW51cCkge1xuICAgIGVsZW1lbnRDbGVhbnVwcy5zZXQoa2V5LCBzZXR1cCgpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZWxlbWVudENsZWFudXBzLmdldChrZXkpPy4oKTtcbiAgICAgIGVsZW1lbnRDbGVhbnVwcy5kZWxldGUoa2V5KTtcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNsZWFudXAgPSBzZXR1cCgpO1xuICBjb25zdCBuZXh0Q2xlYW51cCA9ICgpID0+IHtcbiAgICBjbGVhbnVwKCk7XG4gICAgcHJldkNsZWFudXAoKTtcbiAgICBlbGVtZW50Q2xlYW51cHMuZGVsZXRlKGtleSk7XG4gIH07XG4gIGVsZW1lbnRDbGVhbnVwcy5zZXQoa2V5LCBuZXh0Q2xlYW51cCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgaXNDdXJyZW50ID0gZWxlbWVudENsZWFudXBzLmdldChrZXkpID09PSBuZXh0Q2xlYW51cDtcbiAgICBpZiAoIWlzQ3VycmVudCkgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgICBlbGVtZW50Q2xlYW51cHMuc2V0KGtleSwgcHJldkNsZWFudXApO1xuICB9O1xufVxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsZW1lbnQsIGF0dHIsIHZhbHVlKSB7XG4gIGNvbnN0IHNldHVwID0gKCkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCBwcmV2aW91c1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICByZXR1cm4gc2V0KGVsZW1lbnQsIGF0dHIsIHNldHVwKTtcbn1cbmZ1bmN0aW9uIHNldFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBjb25zdCBzZXR1cCA9ICgpID0+IHtcbiAgICBjb25zdCBleGlzdHMgPSBwcm9wZXJ0eSBpbiBlbGVtZW50O1xuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBlbGVtZW50W3Byb3BlcnR5XTtcbiAgICBlbGVtZW50W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIWV4aXN0cykge1xuICAgICAgICBkZWxldGUgZWxlbWVudFtwcm9wZXJ0eV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50W3Byb3BlcnR5XSA9IHByZXZpb3VzVmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHNldChlbGVtZW50LCBwcm9wZXJ0eSwgc2V0dXApO1xufVxuZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGUpIHtcbiAgaWYgKCFlbGVtZW50KSByZXR1cm4gKCkgPT4ge1xuICB9O1xuICBjb25zdCBzZXR1cCA9ICgpID0+IHtcbiAgICBjb25zdCBwcmV2U3R5bGUgPSBlbGVtZW50LnN0eWxlLmNzc1RleHQ7XG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHByZXZTdHlsZTtcbiAgICB9O1xuICB9O1xuICByZXR1cm4gc2V0KGVsZW1lbnQsIFwic3R5bGVcIiwgc2V0dXApO1xufVxuXG4vLyBzcmMvdmlzdWFsbHktaGlkZGVuLnRzXG52YXIgdmlzdWFsbHlIaWRkZW5TdHlsZSA9IHtcbiAgYm9yZGVyOiBcIjBcIixcbiAgY2xpcDogXCJyZWN0KDAgMCAwIDApXCIsXG4gIGhlaWdodDogXCIxcHhcIixcbiAgbWFyZ2luOiBcIi0xcHhcIixcbiAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gIHBhZGRpbmc6IFwiMFwiLFxuICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICB3aWR0aDogXCIxcHhcIixcbiAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgd29yZFdyYXA6IFwibm9ybWFsXCJcbn07XG5cbi8vIHNyYy93YWl0LWZvci50c1xudmFyIGZwcyA9IDFlMyAvIDYwO1xuZnVuY3Rpb24gd2FpdEZvckVsZW1lbnQocXVlcnkyLCBjYikge1xuICBjb25zdCBlbCA9IHF1ZXJ5MigpO1xuICBpZiAoaXNIVE1MRWxlbWVudChlbCkgJiYgZWwuaXNDb25uZWN0ZWQpIHtcbiAgICBjYihlbCk7XG4gICAgcmV0dXJuICgpID0+IHZvaWQgMDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0aW1lcklkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29uc3QgZWwyID0gcXVlcnkyKCk7XG4gICAgICBpZiAoaXNIVE1MRWxlbWVudChlbDIpICYmIGVsMi5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBjYihlbDIpO1xuICAgICAgICBjbGVhckludGVydmFsKHRpbWVySWQpO1xuICAgICAgfVxuICAgIH0sIGZwcyk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhaXRGb3JFbGVtZW50cyhxdWVyaWVzLCBjYikge1xuICBjb25zdCBjbGVhbnVwczIgPSBbXTtcbiAgcXVlcmllcz8uZm9yRWFjaCgocXVlcnkyKSA9PiB7XG4gICAgY29uc3QgY2xlYW4gPSB3YWl0Rm9yRWxlbWVudChxdWVyeTIsIGNiKTtcbiAgICBjbGVhbnVwczIucHVzaChjbGVhbik7XG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNsZWFudXBzMi5mb3JFYWNoKChmbikgPT4gZm4oKSk7XG4gIH07XG59XG5cbmV4cG9ydCB7IE1BWF9aX0lOREVYLCBhcmlhQXR0ciwgY29udGFpbnMsIGNyZWF0ZVNjb3BlLCBkYXRhQXR0ciwgZGVmYXVsdEl0ZW1Ub0lkLCBnZXRBY3RpdmVFbGVtZW50LCBnZXRCZWZvcmVJbnB1dFZhbHVlLCBnZXRCeVRleHQsIGdldEJ5VHlwZWFoZWFkLCBnZXRDb21wdXRlZFN0eWxlLCBnZXREYXRhVXJsLCBnZXREb2N1bWVudCwgZ2V0RG9jdW1lbnRFbGVtZW50LCBnZXRFdmVudFRhcmdldCwgZ2V0Rmlyc3RGb2N1c2FibGUsIGdldEZpcnN0VGFiYmFibGUsIGdldEZvY3VzYWJsZXMsIGdldEluaXRpYWxGb2N1cywgZ2V0TGFzdFRhYmJhYmxlLCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0TmV4dFRhYmJhYmxlLCBnZXROb2RlTmFtZSwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGdldFBsYXRmb3JtLCBnZXRTY3JvbGxQb3NpdGlvbiwgZ2V0VGFiYmFibGVFZGdlcywgZ2V0VGFiYmFibGVzLCBnZXRXaW5kb3csIGluZGV4T2ZJZCwgaXNBcHBsZSwgaXNDb21wb3NpbmdFdmVudCwgaXNEb2N1bWVudCwgaXNEb20sIGlzRG93bmxvYWRpbmdFdmVudCwgaXNFZGl0YWJsZUVsZW1lbnQsIGlzRmlyZWZveCwgaXNGb2N1c2FibGUsIGlzSFRNTEVsZW1lbnQsIGlzSGlkZGVuRWxlbWVudCwgaXNJblZpZXcsIGlzSW9zLCBpc01hYywgaXNNb2RLZXksIGlzTm9kZSwgaXNPcGVuaW5nSW5OZXdUYWIsIGlzT3ZlcmZsb3dFbGVtZW50LCBpc1Jvb3RFbGVtZW50LCBpc1NhZmFyaSwgaXNTZWxmVGFyZ2V0LCBpc1NoYWRvd1Jvb3QsIGlzVGFiYmFibGUsIGlzVG91Y2hEZXZpY2UsIGlzVmFsaWRUYWJFdmVudCwgaXNWaXN1YWxWaWV3cG9ydCwgaXNXZWJLaXQsIGlzV2luZG93LCBpdGVtQnlJZCwgbmV4dEJ5SWQsIG5leHRUaWNrLCBvYnNlcnZlQXR0cmlidXRlcywgb2JzZXJ2ZUNoaWxkcmVuLCBwcmV2QnlJZCwgcHJveHlUYWJGb2N1cywgcXVlcnksIHF1ZXJ5QWxsLCByYWYsIHNjcm9sbEludG9WaWV3LCBzZXQsIHNldEF0dHJpYnV0ZSwgc2V0UHJvcGVydHksIHNldFN0eWxlLCB2aXN1YWxseUhpZGRlblN0eWxlLCB3YWl0Rm9yRWxlbWVudCwgd2FpdEZvckVsZW1lbnRzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@zag-js+dom-query@0.73.1/node_modules/@zag-js/dom-query/dist/index.mjs\n");

/***/ })

};
;